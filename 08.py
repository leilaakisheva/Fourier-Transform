# -*- coding: utf-8 -*-
"""08

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13OKMY2XQq885gmslup_KcfpQ0kG4NY_7
"""

import numpy as np
import matplotlib.pyplot as plt

import warnings
warnings.filterwarnings('ignore')

"""# Assignment 8
### **Abstract**
This assignment involves generating a signal of the given form, and visualizing it in the time and frequency domain. I will be computing the Fourier Transform of the signal and observing the retrieved frequencies. Additionally, I will be applying the inverse Fourier Transform to the signal and comparing it with the original signal. The assignment also involves regularly sampling the original signal and varying k to observe its effects on the retrieved frequencies. It was found that with increasing k value sampled data decreases and accuracy of the reconstructed data also decreases.

###**Introduction**
Fourier Transform is a mathematical technique used to decompose a signal into its individual frequency components. It is widely used in various fields such as signal processing, communication systems, and image processing. In this assignment, we will be working with regularly sampled data and using the Fourier Transform to retrieve the signal characteristics.

###**Methods**
First I define all the necessary functions. These are the signal function y, Descrete Fourier Transform (DFT), DFT_plot, reconstruction, and k_array. The last one is used for the analysis of changing the behaviour of the sampled data with varying k value.
"""

def y(a,b,B,t):
  return np.sin(a*np.pi*t)+B*np.sin(b*np.pi*t)

def DFT(y):
  N = len(y)
  Y = np.zeros(N)
  for k in range(N):
      for n in range(N):
          Y[k]+=y[n]*np.exp(-1j*2*np.pi*k*n/N) #computing Fourier Transform using Discrete Fourier Transform
  freqs=np.arange(N)/N-0.5 #computing frequency vector
  return freqs, Y, N

def DFT_plot(freqs, Y, N):
  plt.figure(figsize=(8, 6))
  plt.subplot(2, 1, 2)
  plt.plot(freqs, np.abs(Y))
  plt.xlabel('Frequency')
  plt.ylabel('Magnitude')
  plt.title('Fourier Transform')
  plt.xlim(-0.55, 0.55)
  plt.ylim(-10, 65)
  peak_inds = []
  for i in range(1, N-1):
      if np.abs(Y[i])>np.abs(Y[i-1]) and np.abs(Y[i])>np.abs(Y[i+1]):
          peak_inds.append(i)
  #Printing the corresponding frequencies and magnitudes of the peaks
  i=0
  for ind in peak_inds:
      freq=freqs[ind]
      mag=np.abs(Y[ind])
      plt.figtext(0.35, .43-i, "Frequency: {:.2f} Hz, Magnitude: {:.2f}".format(freq, mag))
      i=0.03+i
  plt.show()

def reconstruction(N):
  c=np.zeros(N, dtype=np.complex)
  for k in range(N):
      for n in range(N):
          c[k]+=y[n]*np.exp(-1j*2*np.pi*k*n/N)
  #applying the inverse Fourier Transform
  y_orig=np.zeros(N)
  for n in range(N):
      for k in range(N):
          y_orig[n]+=c[k]*np.exp(1j*2*np.pi*k*n/N)
  y_orig=np.real(y_orig) #getting rid of imaginary part
  return y_orig

def k_array(a,b,B,k_values):
  def y(a,b,B,t):
    return np.sin(a*np.pi*t)+B*np.sin(b*np.pi*t)
  for k in k_values:
    y_k=y(a, b, B, t)[::k] #sampling every k-th element
    N=len(y_k) #num of samples
    Y=np.zeros(N, dtype=complex) #an array to hold the Fourier transform results
    for i in range(N):
        for n in range(N):
            Y[i]+=y_k[n]*np.exp(-1j*2*np.pi*i*n/N) #the Fourier Transform using DFT
    y_orig=np.zeros(N, dtype=complex) #an array to hold the reconstructed signal values
    for n in range(N):
        for i in range(N):
            y_orig[n]+=Y[i]*np.exp(1j*2*np.pi*i*n/N) #the inverse Fourier Transform using IDFT
        y_orig[n] /= N
    #a plot with two subplots
    plt.figure(figsize=(15, 2))
    plt.subplot(1, 2, 1)
    #the original and sampled signals
    plt.plot(t, y(a, b, B, t), label='Original signal')
    plt.plot(t[::k], y_k, 'o', markersize=4, label='Sampled signal')
    plt.xlabel('Time')
    plt.ylabel('Amplitude')
    plt.title(f'Sampled signal, k={k}')
    plt.legend()
    #the reconstructed signal
    plt.subplot(1, 2, 2)
    plt.plot(t[::k], y_orig.real, label='Reconstructed signal')
    plt.xlabel('Time')
    plt.ylabel('Amplitude')
    plt.title(f'Reconstructed signal, k={k}')
    plt.legend()
    plt.show()

a=0.5
b=3
B=2.5
t=np.linspace(-5,5,500)
y = y(a,b,B,t)

"""###**Part A**"""

plt.figure(figsize=(8, 6))
plt.subplot(2, 1, 1)
plt.plot(t,y)
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.title('Signal')

"""###**Part B**"""

freqs, Y, N=DFT(y)

DFT_plot(freqs,Y,N)

"""###**Part C**"""

y_orig=reconstruction(N)

plt.figure(figsize=(8, 6))
plt.subplot(2, 1, 2)
plt.plot(t, y_orig)
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.title('Inverse Fourier Transform')
plt.legend(['Reconstructed signal'])
plt.show()

"""###**Part D**"""

k_values=[2, 3, 4, 5] #the sampling interval k
k_array(a,b,B,k_values)

"""###**Results**
As it can be seen reconstruction of the signal from the Inverse Fourier Transform and the original signal are the same.
In the D part it can be seen that as k value increases number of sampled data decreases and so accuracy is also decreasing.

###**Conclusion**
In this assignment, I generated a signal of the form y = sin(aπt) + Bsin(bπt) with a<1, b>1, and B>1, and visualized it in the time and frequency domain. I computed the Fourier Transform of the signal and observed the retrieved frequencies, and applied the inverse Fourier Transform to the signal and compared it with the original signal. I also regularly sampled the original signal and varied k to observe its effects on the retrieved frequencies.

From the results, I observed that the reconstruction of the signal from the inverse Fourier Transform and the original signal were the same, indicating the effectiveness of the Fourier Transform in retrieving signal characteristics. I also observed that as k value increased in the regularly sampled data, the number of sampled data decreased, and the accuracy of the retrieved frequencies decreased accordingly.

Overall, this assignment provided valuable insights into the application of the Fourier Transform in signal processing and its limitations in regularly sampled data.
"""